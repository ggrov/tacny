.\CSharpConformance.suite failed
source(5593):
using System;
using System.Collections;

public class MyCollection: IEnumerable
{
  int[]  items;

  public MyCollection()
  {
    items = new int[5] {1, 4, 3, 2, 5};
  }

  public MyEnumerator GetEnumerator()
  {
    return new MyEnumerator(this);
  }

  IEnumerator IEnumerable.GetEnumerator() {
        return GetEnumerator();
    }
 
  public class MyEnumerator: IEnumerator
  {
    int        nIndex;
    MyCollection  collection;

    public MyEnumerator(MyCollection coll)
    {
      collection = coll;
      nIndex = -1;
    }
    public bool MoveNext()
    {
      nIndex++;
      return(nIndex < collection.items.GetLength(0));
    }

    public void Reset()
    {
      nIndex = -1;
    }

    public int Current
    {
      get
      {
        return(collection.items[nIndex]);
      }
    }

    object IEnumerator.Current
    {
      get
      {
        return(Current);
      }
    }
  }
}
  
public class Test
{
    public static int Main(string [] args)
    {
    MyCollection  col = new MyCollection();

    foreach (int i in col)
    {
      Console.WriteLine("Value: " + i);
    }

        return(0);
    }
}

actual output:
(4,14): error CS0536: 'MyCollection' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'MyCollection.System.Collections.IEnumerable.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(18,27): (Location of symbol related to previous error)
(18,27): error CS0539: 'MyCollection.System.Collections.IEnumerable.GetEnumerator()' in explicit interface declaration does not match a member of interface 'System.Collections.IEnumerable'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
expected output:
Value: 1
Value: 4
Value: 3
Value: 2
Value: 5
source(19873):
class C {
  public override bool Equals(object obj) { return true; }
  public override int GetHashCode() { return 3; }
  public static bool operator == (C v1, C v2) { return true; }
  public static bool operator != (C v1, C v2) { return true; }
  void f(C c) { if (c != null) return; }
  public static void Main(){}
}

actual output:
(2,24): error CS2681: 'C.Equals(object)' is not pure enough. It either overrides or implements 'object.Equals(object)' which is marked as '[Pure][Reads(ReadsAttribute.Reads.Nothing)]'
(3,23): error CS2681: 'C.GetHashCode()' is not pure enough. It either overrides or implements 'object.GetHashCode()' which is marked as '[Pure]'
expected output:

source(20449):
using System;
using System.Collections;

class S : ISet {
    
    void ICollection.CopyTo(Array target, int index) {
    }

    public int Count { get { return 0; } }

    public object SyncRoot { get { return this; } }

    public bool IsSynchronized { get { return false; } }

    public IEnumerator GetEnumerator() { return null; }
    
    public static void Main(){}
}


interface ISet : ICollection {
}

actual output:
(4,7): error CS0535: 'S' does not implement interface member 'System.Collections.ICollection.CopyTo(System.Array!, int)'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(4,7): error CS0536: 'S' does not implement interface member 'System.Collections.ICollection.SyncRoot.get'. 'S.SyncRoot.get' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(11,30): (Location of symbol related to previous error)
(4,7): error CS0536: 'S' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'S.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(15,24): (Location of symbol related to previous error)
(6,22): error CS0539: 'S.System.Collections.ICollection.CopyTo(System.Array, int)' in explicit interface declaration does not match a member of interface 'System.Collections.ICollection'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
expected output:

source(21937):
using System;

public unsafe class TestClass
{
    public int PerformTest()
    {
        long num;
        int* ptr;

        num = 100;
        ptr = (int*)num;
        if ((long)ptr != 100)
            return 1;

        num = long.MaxValue;            
        ptr = (int*)num;
        if ((long)ptr != (long.MaxValue & 0xFFFFFFFF))
            return 2;

        num = long.MinValue;            
        ptr = (int*)num;
        if ((long)ptr != (long.MinValue & 0xFFFFFFFF))
            return 3;
        
        return 0;
    }
}

public class TestDriver
{
  unsafe static int Main() 
    {
        return new TestClass().PerformTest();
    }
}

actual output:
Non zero return code: 2
expected output:

source(23641):
using System;
using System.Collections.Generic;

public struct Gen<T> : IEnumerable<T>  
{
  T[] Values;
  
  public Gen(T[] Values)
  {
    this.Values = Values;    
  }
  
  public IEnumerator<T>  GetEnumerator()
  {
    foreach(T Value in Values)
    {
      yield return Value;
    }
  }

  System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
  {
    return this.GetEnumerator();
  }

  public static void TestForeach(Gen<T> G, T[] Arr)
  {
    ((VerifyIterator<T>)
      delegate(Gen<T> XG, T[] XArr) 
      { 
        int i = 0;
        foreach(T val in XG)
        {
          Test.Eval(val.Equals(XArr[i++]));
        }
      }
    )(G,Arr); 
  }
}


public delegate void VerifyIterator<T>(Gen<T> G, T[] Arr);

public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {
    Gen<int>.TestForeach(new Gen<int>(new int[]{1,2,3,4,5,6,7,8,9}),new int[]{1,2,3,4,5,6,7,8,9});
    Gen<string>.TestForeach(new Gen<string>(new string[]{"1","2","3","4","5","6","7","8","9"}),new string[]{"1","2","3","4","5","6","7","8","9"});
  
    if (result)
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
    
}

actual output:
(4,15): error CS0536: 'Gen<T>' does not implement interface member 'System.Collections.Generic.IEnumerable<T>.GetEnumerator()'. 'Gen<T>.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(13,26): (Location of symbol related to previous error)
(4,15): error CS0536: 'Gen<T>' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'Gen<T>.System.Collections.IEnumerable.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(21,65): (Location of symbol related to previous error)
(21,65): error CS0539: 'Gen<T>.System.Collections.IEnumerable.GetEnumerator()' in explicit interface declaration does not match a member of interface 'System.Collections.IEnumerable'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
expected output:

source(26376):
using System;

public class SpecializedSubGenericClassInt : GenericClass<int>
{

  public SpecializedSubGenericClassInt() : base() {}
  public SpecializedSubGenericClassInt(int t) : base(t) {}
  public SpecializedSubGenericClassInt(GC1<int> g) : base(g) {}
  

  public static void TestCtors(int t)
  {
    new SpecializedSubGenericClassInt();
    Test.Eval(String.Format("GenericClass[{0}].ctor()",typeof(int)), TestVerificationStore.LastAction);

    new SpecializedSubGenericClassInt(t);
    Test.Eval(String.Format("GenericClass[{0}].ctor(T)",typeof(int)), TestVerificationStore.LastAction);
    
    new SpecializedSubGenericClassInt(new GC1<int>(t));
    Test.Eval(String.Format("GenericClass[{0}].ctor(GC1<T>)",typeof(int)), TestVerificationStore.LastAction);
  }
  
  public void TestBaseMemberAccessWithNoQualifiers(int TestValue)
  {
    Fld1 = TestValue;
    Test.Eval(TestValue,Fld1);

    sFld1 = TestValue;
    Test.Eval(TestValue,sFld1);

    Fld2 = new GC1<int>(TestValue);
    Test.Eval(new GC1<int>(TestValue),Fld2);

    sFld2 = new GC1<int>(TestValue);
    Test.Eval(new GC1<int>(TestValue),sFld2);

    Fld3 = new GS1<int>(TestValue);
    Test.Eval(new GS1<int>(TestValue),Fld3);

    sFld3 = new GS1<int>(TestValue);
    Test.Eval(new GS1<int>(TestValue),sFld3);

    int t;
  
    Prop1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].Prop1.set",typeof(int)), TestVerificationStore.LastAction);

    t = Prop1;
    Test.Eval(String.Format("GenericClass[{0}].Prop1.get",typeof(int)), TestVerificationStore.LastAction);

    vProp1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].vProp1.set",typeof(int)), TestVerificationStore.LastAction);

    t = vProp1;
    Test.Eval(String.Format("GenericClass[{0}].vProp1.get",typeof(int)), TestVerificationStore.LastAction);

    sProp1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].sProp1.set",typeof(int)), TestVerificationStore.LastAction);

    t = sProp1;
    Test.Eval(String.Format("GenericClass[{0}].sProp1.get",typeof(int)), TestVerificationStore.LastAction);


    GC1<int> gc1t;
    
    Prop2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = Prop2;
    Test.Eval(String.Format("GenericClass[{0}].Prop2.get",typeof(int)), TestVerificationStore.LastAction);

    vProp2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = vProp2;
    Test.Eval(String.Format("GenericClass[{0}].vProp2.get",typeof(int)), TestVerificationStore.LastAction);

    sProp2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].sProp2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = sProp2;
    Test.Eval(String.Format("GenericClass[{0}].sProp2.get",typeof(int)), TestVerificationStore.LastAction);

    GS1<int> gs1t;
    
    Prop3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = Prop3;
    Test.Eval(String.Format("GenericClass[{0}].Prop3.get",typeof(int)), TestVerificationStore.LastAction);

    vProp3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = vProp3;
    Test.Eval(String.Format("GenericClass[{0}].vProp3.get",typeof(int)), TestVerificationStore.LastAction);

    sProp3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].sProp3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = sProp3;
    Test.Eval(String.Format("GenericClass[{0}].sProp3.get",typeof(int)), TestVerificationStore.LastAction);

    Ev += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.add",typeof(int)), TestVerificationStore.LastAction);

    Ev -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.remove",typeof(int)), TestVerificationStore.LastAction);

    vEv += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.add",typeof(int)), TestVerificationStore.LastAction);

    vEv -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.remove",typeof(int)), TestVerificationStore.LastAction);

    sEv += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].sEv.add",typeof(int)), TestVerificationStore.LastAction);

    sEv -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].sEv.remove",typeof(int)), TestVerificationStore.LastAction);

    GenDlg<GC1<int>> DFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].FldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DvFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].vFldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DsFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].sFldEv",typeof(int));return x;};
    
    FldEv += DFldEv;
    FireFldEv();
    Test.Eval(String.Format("GenericClass[{0}].FldEv",typeof(int)), TestVerificationStore.LastAction);
    FldEv -= DFldEv;
    try { FireFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on FldEv",E);}

        
    vFldEv += DvFldEv;
    FirevFldEv();
    Test.Eval(String.Format("GenericClass[{0}].vFldEv",typeof(int)), TestVerificationStore.LastAction);
    vFldEv -= DvFldEv;
    try { FirevFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on vFldEv",E);}

        
    sFldEv += DsFldEv;
    FiresFldEv();
    Test.Eval(String.Format("GenericClass[{0}].sFldEv",typeof(int)), TestVerificationStore.LastAction);
    sFldEv -= DsFldEv;
    try { FiresFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on sFldEv",E);}

    Meth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth1",typeof(int)),TestVerificationStore.LastAction);

    vMeth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth1",typeof(int)),TestVerificationStore.LastAction);

    sMeth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth1",typeof(int)),TestVerificationStore.LastAction);
    
    Meth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth2",typeof(int)),TestVerificationStore.LastAction);

    vMeth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth2",typeof(int)),TestVerificationStore.LastAction);

    sMeth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth2",typeof(int)),TestVerificationStore.LastAction);

    Meth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth3",typeof(int)),TestVerificationStore.LastAction);

    vMeth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth3",typeof(int)),TestVerificationStore.LastAction);

    sMeth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth3",typeof(int)),TestVerificationStore.LastAction);

    GC1<int> GC1TVal = default(GC1<int>);
    
    Meth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth4",typeof(int)),TestVerificationStore.LastAction);

    vMeth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth4",typeof(int)),TestVerificationStore.LastAction);

    sMeth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth4",typeof(int)),TestVerificationStore.LastAction);

    Meth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth5",typeof(int)),TestVerificationStore.LastAction);

    vMeth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth5",typeof(int)),TestVerificationStore.LastAction);

    sMeth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth5",typeof(int)),TestVerificationStore.LastAction);

    Meth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth6",typeof(int)),TestVerificationStore.LastAction);

    vMeth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth6",typeof(int)),TestVerificationStore.LastAction);

    sMeth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth6",typeof(int)),TestVerificationStore.LastAction);

    int[] TArr = new int[] {};
    
    Meth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth7",typeof(int)),TestVerificationStore.LastAction);

    vMeth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth7",typeof(int)),TestVerificationStore.LastAction);

    sMeth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth7",typeof(int)),TestVerificationStore.LastAction);

    Meth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth8",typeof(int)),TestVerificationStore.LastAction);

    vMeth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth8",typeof(int)),TestVerificationStore.LastAction);

    sMeth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth8",typeof(int)),TestVerificationStore.LastAction);

    Meth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth9",typeof(int)),TestVerificationStore.LastAction);

    vMeth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth9",typeof(int)),TestVerificationStore.LastAction);

    sMeth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth9",typeof(int)),TestVerificationStore.LastAction);

    Meth10(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth10",typeof(int)),TestVerificationStore.LastAction);

    vMeth10(TestValue, TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth10",typeof(int)),TestVerificationStore.LastAction);

    sMeth10();
    Test.Eval(String.Format("GenericClass[{0}].sMeth10",typeof(int)),TestVerificationStore.LastAction);

    Meth11(new GC1<int>[]{});
    Test.Eval(String.Format("GenericClass[{0}].Meth11",typeof(int)),TestVerificationStore.LastAction);

    vMeth11(GC1TVal, GC1TVal, GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth11",typeof(int)),TestVerificationStore.LastAction);

    sMeth11();
    Test.Eval(String.Format("GenericClass[{0}].sMeth11",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int> GenericClassT;

    GenericClassT = new SpecializedSubGenericClassInt() + new SpecializedSubGenericClassInt();
    Test.Eval(String.Format("GenericClass[{0}].op_Addition",typeof(int)),TestVerificationStore.LastAction);

    GenericClassT++;
    Test.Eval(String.Format("GenericClass[{0}].op_incr",typeof(int)),TestVerificationStore.LastAction);

    if (GenericClassT) 
    {
      Test.Eval(String.Format("GenericClass[{0}].op_true",typeof(int)),TestVerificationStore.LastAction);
    }

    if (((GenericClass<int>)null) && new SpecializedSubGenericClassInt()) 
    {
      Test.Eval(String.Format("GenericClass[{0}].op_false",typeof(int)),TestVerificationStore.LastAction);
    }
    
    GC1<int> GenericClassGC1T = default(GenericClass<int>);
    GS1<int> GenericClassGS1T = (GS1<int>) default(GenericClass<int>);

  }

  public void TestBaseMemberAccessWithBaseQualifier(int TestValue)
  {
    base.Fld1 = TestValue;
    Test.Eval(TestValue,base.Fld1);

    base.Fld2 = new GC1<int>(TestValue);
    Test.Eval(new GC1<int>(TestValue),base.Fld2);

    base.Fld3 = new GS1<int>(TestValue);
    Test.Eval(new GS1<int>(TestValue),base.Fld3);

    int t;
    GC1<int> GC1TVal = default(GC1<int>);
    GS1<int> GS1TVal = default(GS1<int>);

    base.Prop1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].Prop1.set",typeof(int)), TestVerificationStore.LastAction);

    t = base.Prop1;
    Test.Eval(String.Format("GenericClass[{0}].Prop1.get",typeof(int)), TestVerificationStore.LastAction);

    base.vProp1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].vProp1.set",typeof(int)), TestVerificationStore.LastAction);

    t = base.vProp1;
    Test.Eval(String.Format("GenericClass[{0}].vProp1.get",typeof(int)), TestVerificationStore.LastAction);

    GC1<int> gc1t;
    
    base.Prop2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = base.Prop2;
    Test.Eval(String.Format("GenericClass[{0}].Prop2.get",typeof(int)), TestVerificationStore.LastAction);

    base.vProp2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = base.vProp2;
    Test.Eval(String.Format("GenericClass[{0}].vProp2.get",typeof(int)), TestVerificationStore.LastAction);

    GS1<int> gs1t;
    
    base.Prop3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = base.Prop3;
    Test.Eval(String.Format("GenericClass[{0}].Prop3.get",typeof(int)), TestVerificationStore.LastAction);

    base.vProp3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = base.vProp3;
    Test.Eval(String.Format("GenericClass[{0}].vProp3.get",typeof(int)), TestVerificationStore.LastAction);

    base[1] = TestValue;
    Test.Eval(String.Format("GenericClass[{0}].this1.set",typeof(int)), TestVerificationStore.LastAction);
  
    TestValue = base[1];
    Test.Eval(String.Format("GenericClass[{0}].this1.get",typeof(int)), TestVerificationStore.LastAction);
  
    base[GC1TVal,TestValue] = GC1TVal;
    Test.Eval(String.Format("GenericClass[{0}].this2.set",typeof(int)), TestVerificationStore.LastAction);
  
    GC1TVal = base[GC1TVal,TestValue];
    Test.Eval(String.Format("GenericClass[{0}].this2.get",typeof(int)), TestVerificationStore.LastAction);
  
    base[GS1TVal] = TestValue;
    Test.Eval(String.Format("GenericClass[{0}].vthis1.set",typeof(int)), TestVerificationStore.LastAction);
  
    TestValue = base[GS1TVal];
    Test.Eval(String.Format("GenericClass[{0}].vthis1.get",typeof(int)), TestVerificationStore.LastAction);

    base["1",TestValue] = GC1TVal;
    Test.Eval(String.Format("GenericClass[{0}].vthis2.set",typeof(int)), TestVerificationStore.LastAction);
  
    GC1TVal = base["1",TestValue];
    Test.Eval(String.Format("GenericClass[{0}].vthis2.get",typeof(int)), TestVerificationStore.LastAction);
  
    base.Ev += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.add",typeof(int)), TestVerificationStore.LastAction);

    base.Ev -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.remove",typeof(int)), TestVerificationStore.LastAction);

    base.vEv += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.add",typeof(int)), TestVerificationStore.LastAction);

    base.vEv -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.remove",typeof(int)), TestVerificationStore.LastAction);

    GenDlg<GC1<int>> DFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].FldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DvFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].vFldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DsFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].sFldEv",typeof(int));return x;};
    
    base.FldEv += DFldEv;
    FireFldEv();
    Test.Eval(String.Format("GenericClass[{0}].FldEv",typeof(int)), TestVerificationStore.LastAction);
    base.FldEv -= DFldEv;
    try { FireFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on FldEv",E);}

        
    base.vFldEv += DvFldEv;
    FirevFldEv();
    Test.Eval(String.Format("GenericClass[{0}].vFldEv",typeof(int)), TestVerificationStore.LastAction);
    base.vFldEv -= DvFldEv;
    try { FirevFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on vFldEv",E);}

    base.Meth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth1",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth1",typeof(int)),TestVerificationStore.LastAction);
    
    base.Meth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth2",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth2",typeof(int)),TestVerificationStore.LastAction);

    base.Meth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth3",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth3",typeof(int)),TestVerificationStore.LastAction);

    GC1TVal = default(GC1<int>);
    
    base.Meth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth4",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth4",typeof(int)),TestVerificationStore.LastAction);

    base.Meth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth5",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth5",typeof(int)),TestVerificationStore.LastAction);

    base.Meth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth6",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth6",typeof(int)),TestVerificationStore.LastAction);

    int[] TArr = new int[] {};
    
    base.Meth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth7",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth7",typeof(int)),TestVerificationStore.LastAction);
    
    base.Meth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth8",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth8",typeof(int)),TestVerificationStore.LastAction);

    base.Meth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth9",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth9",typeof(int)),TestVerificationStore.LastAction);

    base.Meth10(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth10",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth10(TestValue, TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth10",typeof(int)),TestVerificationStore.LastAction);

    base.Meth11(new GC1<int>[]{});
    Test.Eval(String.Format("GenericClass[{0}].Meth11",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth11(GC1TVal, GC1TVal, GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth11",typeof(int)),TestVerificationStore.LastAction);
  }  

  public void TestBaseMemberAccessWithThisQualifier(int TestValue)
  {
    this.Fld1 = TestValue;
    Test.Eval(TestValue,this.Fld1);

    this.Fld2 = new GC1<int>(TestValue);
    Test.Eval(new GC1<int>(TestValue),this.Fld2);

    this.Fld3 = new GS1<int>(TestValue);
    Test.Eval(new GS1<int>(TestValue),this.Fld3);

    int t;
    GC1<int> GC1TVal = default(GC1<int>);
    GS1<int> GS1TVal = default(GS1<int>);

    this.Prop1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].Prop1.set",typeof(int)), TestVerificationStore.LastAction);

    t = this.Prop1;
    Test.Eval(String.Format("GenericClass[{0}].Prop1.get",typeof(int)), TestVerificationStore.LastAction);

    this.vProp1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].vProp1.set",typeof(int)), TestVerificationStore.LastAction);

    t = this.vProp1;
    Test.Eval(String.Format("GenericClass[{0}].vProp1.get",typeof(int)), TestVerificationStore.LastAction);

    GC1<int> gc1t;
    
    this.Prop2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = this.Prop2;
    Test.Eval(String.Format("GenericClass[{0}].Prop2.get",typeof(int)), TestVerificationStore.LastAction);

    this.vProp2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = this.vProp2;
    Test.Eval(String.Format("GenericClass[{0}].vProp2.get",typeof(int)), TestVerificationStore.LastAction);

    GS1<int> gs1t;
    
    this.Prop3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = this.Prop3;
    Test.Eval(String.Format("GenericClass[{0}].Prop3.get",typeof(int)), TestVerificationStore.LastAction);

    this.vProp3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = this.vProp3;
    Test.Eval(String.Format("GenericClass[{0}].vProp3.get",typeof(int)), TestVerificationStore.LastAction);

    this[1] = TestValue;
    Test.Eval(String.Format("GenericClass[{0}].this1.set",typeof(int)), TestVerificationStore.LastAction);
  
    TestValue = this[1];
    Test.Eval(String.Format("GenericClass[{0}].this1.get",typeof(int)), TestVerificationStore.LastAction);
  
    this[GC1TVal,TestValue] = GC1TVal;
    Test.Eval(String.Format("GenericClass[{0}].this2.set",typeof(int)), TestVerificationStore.LastAction);
  
    GC1TVal = this[GC1TVal,TestValue];
    Test.Eval(String.Format("GenericClass[{0}].this2.get",typeof(int)), TestVerificationStore.LastAction);
  
    this[GS1TVal] = TestValue;
    Test.Eval(String.Format("GenericClass[{0}].vthis1.set",typeof(int)), TestVerificationStore.LastAction);
  
    TestValue = this[GS1TVal];
    Test.Eval(String.Format("GenericClass[{0}].vthis1.get",typeof(int)), TestVerificationStore.LastAction);

    this["1",TestValue] = GC1TVal;
    Test.Eval(String.Format("GenericClass[{0}].vthis2.set",typeof(int)), TestVerificationStore.LastAction);
  
    GC1TVal = this["1",TestValue];
    Test.Eval(String.Format("GenericClass[{0}].vthis2.get",typeof(int)), TestVerificationStore.LastAction);

    this.Ev += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.add",typeof(int)), TestVerificationStore.LastAction);

    this.Ev -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.remove",typeof(int)), TestVerificationStore.LastAction);

    this.vEv += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.add",typeof(int)), TestVerificationStore.LastAction);

    this.vEv -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.remove",typeof(int)), TestVerificationStore.LastAction);

    GenDlg<GC1<int>> DFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].FldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DvFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].vFldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DsFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].sFldEv",typeof(int));return x;};
    
    this.FldEv += DFldEv;
    FireFldEv();
    Test.Eval(String.Format("GenericClass[{0}].FldEv",typeof(int)), TestVerificationStore.LastAction);
    this.FldEv -= DFldEv;
    try { FireFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on FldEv",E);}

        
    this.vFldEv += DvFldEv;
    FirevFldEv();
    Test.Eval(String.Format("GenericClass[{0}].vFldEv",typeof(int)), TestVerificationStore.LastAction);
    this.vFldEv -= DvFldEv;
    try { FirevFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on vFldEv",E);}

    this.Meth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth1",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth1",typeof(int)),TestVerificationStore.LastAction);
    
    this.Meth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth2",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth2",typeof(int)),TestVerificationStore.LastAction);

    this.Meth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth3",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth3",typeof(int)),TestVerificationStore.LastAction);

    GC1TVal = default(GC1<int>);
    
    this.Meth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth4",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth4",typeof(int)),TestVerificationStore.LastAction);

    this.Meth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth5",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth5",typeof(int)),TestVerificationStore.LastAction);

    this.Meth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth6",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth6",typeof(int)),TestVerificationStore.LastAction);

    int[] TArr = new int[] {};
    
    this.Meth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth7",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth7",typeof(int)),TestVerificationStore.LastAction);
    
    this.Meth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth8",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth8",typeof(int)),TestVerificationStore.LastAction);

    this.Meth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth9",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth9",typeof(int)),TestVerificationStore.LastAction);

    this.Meth10(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth10",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth10(TestValue, TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth10",typeof(int)),TestVerificationStore.LastAction);

    this.Meth11(new GC1<int>[]{});
    Test.Eval(String.Format("GenericClass[{0}].Meth11",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth11(GC1TVal, GC1TVal, GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth11",typeof(int)),TestVerificationStore.LastAction);

  }  

  public void TestBaseStaticMemberAccessWithBaseNameQualifier(int TestValue)
  {
    GenericClass<int>.sFld1 = TestValue;
    Test.Eval(TestValue,GenericClass<int>.sFld1);

    GenericClass<int>.sFld2 = new GC1<int>(TestValue);
    Test.Eval(new GC1<int>(TestValue),GenericClass<int>.sFld2);

    GenericClass<int>.sFld3 = new GS1<int>(TestValue);
    Test.Eval(new GS1<int>(TestValue),GenericClass<int>.sFld3);

    int t;

    GenericClass<int>.sProp1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].sProp1.set",typeof(int)), TestVerificationStore.LastAction);

    t = GenericClass<int>.sProp1;
    Test.Eval(String.Format("GenericClass[{0}].sProp1.get",typeof(int)), TestVerificationStore.LastAction);

    GC1<int> gc1t;
    
    GenericClass<int>.sProp2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].sProp2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = GenericClass<int>.sProp2;
    Test.Eval(String.Format("GenericClass[{0}].sProp2.get",typeof(int)), TestVerificationStore.LastAction);

    GS1<int> gs1t;

    GenericClass<int>.sProp3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].sProp3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = GenericClass<int>.sProp3;
    Test.Eval(String.Format("GenericClass[{0}].sProp3.get",typeof(int)), TestVerificationStore.LastAction);

    GenericClass<int>.sEv += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].sEv.add",typeof(int)), TestVerificationStore.LastAction);

    GenericClass<int>.sEv -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].sEv.remove",typeof(int)), TestVerificationStore.LastAction);

    GenDlg<GC1<int>> DFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].FldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DvFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].vFldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DsFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].sFldEv",typeof(int));return x;};
            
    GenericClass<int>.sFldEv += DsFldEv;
    FiresFldEv();
    Test.Eval(String.Format("GenericClass[{0}].sFldEv",typeof(int)), TestVerificationStore.LastAction);
    GenericClass<int>.sFldEv -= DsFldEv;
    try { FiresFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on sFldEv",E);}

    GenericClass<int>.sMeth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth1",typeof(int)),TestVerificationStore.LastAction);
    
    GenericClass<int>.sMeth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth2",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth3",typeof(int)),TestVerificationStore.LastAction);

    GC1<int> GC1TVal = default(GC1<int>);
    
    GenericClass<int>.sMeth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth4",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth5",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth6",typeof(int)),TestVerificationStore.LastAction);

    int[] TArr = new int[] {};
    
    GenericClass<int>.sMeth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth7",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth8",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth9",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth10();
    Test.Eval(String.Format("GenericClass[{0}].sMeth10",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth11();
    Test.Eval(String.Format("GenericClass[{0}].sMeth11",typeof(int)),TestVerificationStore.LastAction);

  }

  public void TestNestedTypeBaseMemberAccess()
  {
    #pragma warning disable 219
    GenericClass<int>.NestedClass NC = default(NestedClass);
    GenericClass<int>.NestedStruct NS = default(NestedStruct);
    GenericClass<int>.NestedInterface NI = default(NestedInterface);
    GenericClass<int>.NestedEnum NE = default(NestedEnum);
    GenericClass<int>.NestedDelegate ND = default(NestedDelegate);
    #pragma warning restore 219
  }
  
}
public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(object obj1, object obj2)
  {
    counter++;

    if ( (!(null == obj1 && null == obj2)) && (null == obj1 || null == obj2 || !obj1.Equals(obj2)))
    {
      result = false;
      Console.WriteLine("Test Failed at location: " + counter);
      Console.WriteLine("Expected: [{0}]\nGot: [{1}]\n", obj1, obj2);
    }
  }

  public static int Main()
  {
    SpecializedSubGenericClassInt.TestCtors(1);
    
    new SpecializedSubGenericClassInt().TestBaseMemberAccessWithNoQualifiers(1);
    new SpecializedSubGenericClassInt().TestBaseMemberAccessWithBaseQualifier(1);
    new SpecializedSubGenericClassInt().TestBaseMemberAccessWithThisQualifier(1);
    new SpecializedSubGenericClassInt().TestBaseStaticMemberAccessWithBaseNameQualifier(1);
    new SpecializedSubGenericClassInt().TestNestedTypeBaseMemberAccess();
    
              if (result)
              {
      return 0;
    }
    else
    {
      return 1;
    }
  }
}

// </Code>
// Define the generic class to be used as base


public delegate T GenDlg<T>(T t);
public delegate string Dlg(string s);

public interface GI1<T> {}
public class GC1<T>
{
  T t;
  public GC1(T t) {this.t = t;}
  public override bool Equals(object obj) 
  { 
    return (obj != null && obj.GetType().Equals(typeof(GC1<T>)) && ((((GC1<T>)obj).t == null && t == null) || ((GC1<T>)obj).t != null && ((GC1<T>)obj).t.Equals(t)));
  }
  public override int GetHashCode() {return base.GetHashCode();}

}

public struct GS1<T>
{
  T t;
  public GS1(T t) {this.t = t;}
  public override bool Equals(object obj) 
  { 
    return (obj != null && obj.GetType().Equals(typeof(GS1<T>)) && ((((GS1<T>)obj).t == null && t == null) || ((GS1<T>)obj).t != null && ((GS1<T>)obj).t.Equals(t)));
  }  
  public override int GetHashCode() {return base.GetHashCode();}
}

public class TestVerificationStore
{
  public static string LastAction;
  public static void SetLastAction(string format, params object[] args) 
  { 
    LastAction = String.Format(format, args); 
  }
}

public class GenericClass<T>
{
  protected GenericClass()
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].ctor()",typeof(T));
  }
  
  protected GenericClass(T t)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].ctor(T)",typeof(T));
  }
  protected GenericClass(GC1<T> G)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].ctor(GC1<T>)",typeof(T));
  }
  
  protected T Fld1;
  protected static T sFld1;

  protected GC1<T> Fld2;
  protected static GC1<T> sFld2;

  protected GS1<T> Fld3;
  protected static GS1<T> sFld3;

  protected T Prop1
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop1.get",typeof(T));
      return Fld1; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop1.set",typeof(T));
      Fld1 = value; 
    } 
  }
  
  protected virtual T vProp1
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp1.get",typeof(T));
      return Fld1; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp1.set",typeof(T));
      Fld1 = value; 
    } 
  }

  protected static T sProp1
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp1.get",typeof(T));
      return sFld1; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp1.set",typeof(T));
      sFld1 = value; 
    } 
  }

  protected GC1<T> Prop2
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop2.get",typeof(T));
      return Fld2; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop2.set",typeof(T));
      Fld2 = value; 
    } 
  }
  
  protected virtual GC1<T> vProp2 
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp2.get",typeof(T));
      return Fld2; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp2.set",typeof(T));
      Fld2 = value; 
    } 
  }

  protected static GC1<T> sProp2
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp2.get",typeof(T));
      return sFld2; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp2.set",typeof(T));
      sFld2 = value; 
    } 
  }

  protected GS1<T> Prop3
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop3.get",typeof(T));
      return Fld3; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop3.set",typeof(T));
      Fld3 = value; 
    } 
  }
  
  protected virtual GS1<T> vProp3 
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp3.get",typeof(T));
      return Fld3; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp3.set",typeof(T));
      Fld3 = value; 
    } 
  }

  protected static GS1<T> sProp3
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp3.get",typeof(T));
      return sFld3; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp3.set",typeof(T));
      sFld3 = value; 
    } 
  }


  protected T this[int i]
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].this1.get",typeof(T));
      return Fld1; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].this1.set",typeof(T));
      Fld1 = value; 
    } 
  }

  protected GC1<T> this[GC1<T> i, T t]
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].this2.get",typeof(T));
      return Fld2; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].this2.set",typeof(T));
      Fld2 = value; 
    } 
  }

  protected virtual T this[GS1<T> i]
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vthis1.get",typeof(T));
      return Fld1; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vthis1.set",typeof(T));
      Fld1 = value; 
    } 
  }
  
  protected virtual GC1<T> this[string s, T t] 
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vthis2.get",typeof(T));
      return Fld2; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vthis2.set",typeof(T));
      Fld2 = value; 
    } 
  }
  
  protected  event GenDlg<T> Ev
  {
    add 
    {
      TestVerificationStore.SetLastAction("GenericClass[{0}].Ev.add",typeof(T));
    }
    remove
    {
      TestVerificationStore.SetLastAction("GenericClass[{0}].Ev.remove",typeof(T));
    }
  }
  
  protected  virtual event GenDlg<T> vEv
  {
    add 
    {
      TestVerificationStore.SetLastAction("GenericClass[{0}].vEv.add",typeof(T));  
    }
    remove
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vEv.remove",typeof(T));
    }
  }

  protected static event GenDlg<T> sEv
  {
    add 
    {
      TestVerificationStore.SetLastAction("GenericClass[{0}].sEv.add",typeof(T));
    }
    remove
    {
      TestVerificationStore.SetLastAction("GenericClass[{0}].sEv.remove",typeof(T));
    }
  }

  
  protected event GenDlg<GC1<T>> FldEv;

  protected GC1<T> FireFldEv()
  {
    return FldEv(default(GC1<T>));
  }

  protected virtual event GenDlg<GC1<T>> vFldEv;

  protected virtual GC1<T> FirevFldEv()
  {
    return vFldEv(default(GC1<T>));
  }

  protected static event GenDlg<GC1<T>> sFldEv;

  protected static GC1<T> FiresFldEv()
  {
    return sFldEv(default(GC1<T>));
  }
  
  protected T Meth1(T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth1",typeof(T));
    return Fld1; 
  }
  
  protected virtual T vMeth1(T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth1",typeof(T));
    return Fld1; 
  }

  protected static T sMeth1(T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth1",typeof(T));
    return sFld1; 
  }

  protected T Meth2(out T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth2",typeof(T));
    t = Fld1;
    return Fld1; 
  }
  
  protected virtual T vMeth2(out T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth2",typeof(T));
    t = Fld1;
    return Fld1; 
  }

  protected static T sMeth2(out T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth2",typeof(T));
    t = sFld1;
    return sFld1; 
  }

  protected T Meth3(ref T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth3",typeof(T));
    t = Fld1;
    return Fld1; 
  }
  
  protected virtual T vMeth3(ref T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth3",typeof(T));
    t = Fld1;
    return Fld1; 
  }

  protected static T sMeth3(ref T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth3",typeof(T));
    t = sFld1;
    return sFld1; 
  }

  protected GC1<T> Meth4(GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth4",typeof(T));
    return Fld2; 
  }
  
  protected virtual GC1<T> vMeth4(GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth4",typeof(T));
    return Fld2; 
  }

  protected static GC1<T> sMeth4(GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth4",typeof(T));
    return sFld2; 
  }

  protected GC1<T> Meth5(out GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth5",typeof(T));
    t = default(GC1<T>);
    return Fld2; 
  }
  
  protected virtual GC1<T> vMeth5(out GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth5",typeof(T));
    t = default(GC1<T>);
    return Fld2; 
  }

  protected static GC1<T> sMeth5(out GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth5",typeof(T));
    t = default(GC1<T>);
    return sFld2; 
  }

  protected GC1<T> Meth6(ref GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth6",typeof(T));
    t = default(GC1<T>);
    return Fld2; 
  }
  
  protected virtual GC1<T> vMeth6(ref GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth6",typeof(T));
    t = default(GC1<T>);
    return Fld2; 
  }

  protected static GC1<T> sMeth6(ref GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth6",typeof(T));
    t = default(GC1<T>);
    return sFld2; 
  }

  protected T Meth7(T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth7",typeof(T));
    return Fld1; 
  }
  
  protected virtual T vMeth7(T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth7",typeof(T));
    return Fld1; 
  }

  protected static T sMeth7(T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth7",typeof(T));
    return sFld1; 
  }

  protected T Meth8(out T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth8",typeof(T));
    t = null;
    return Fld1; 
  }
  
  protected virtual T vMeth8(out T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth8",typeof(T));
    t = null;
    return Fld1; 
  }

  protected static T sMeth8(out T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth8",typeof(T));
    t = null;
    return sFld1; 
  }

  protected T Meth9(ref T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth9",typeof(T));
    t = null;
    return Fld1; 
  }
  
  protected virtual T vMeth9(ref T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth9",typeof(T));
    t = null;
    return Fld1; 
  }

  protected static T sMeth9(ref T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth9",typeof(T));
    t = null;
    return sFld1; 
  }

  protected T Meth10(params T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth10",typeof(T));
    return Fld1; 
  }
  
  protected virtual T vMeth10(params T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth10",typeof(T));
    return Fld1; 
  }

  protected static T sMeth10(params T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth10",typeof(T));
    return sFld1; 
  }

  protected T Meth11(params GC1<T>[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth11",typeof(T));
    return Fld1; 
  }
  
  protected virtual T vMeth11(params GC1<T>[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth11",typeof(T));
    return Fld1; 
  }

  protected static T sMeth11(params GC1<T>[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth11",typeof(T));
    return sFld1; 
  }
  
  public static GenericClass<T> operator + (GenericClass<T> G1, GenericClass<T> G2)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_Addition",typeof(T));
    return G1;
  }

  public static GenericClass<T> operator ++ (GenericClass<T> G1)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_incr",typeof(T));
    return G1;
  }

  public static bool operator true (GenericClass<T> G)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_true",typeof(T));
    return (G != null);
  }

  public static bool operator false (GenericClass<T> G)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_false",typeof(T));
    return (G == null);
  }

  public static GenericClass<T> operator & (GenericClass<T> G1, GenericClass<T> G2)
  {
    return G1;
  }

  public static implicit operator GC1<T> (GenericClass<T> G)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_impl",typeof(T));
    return default(GC1<T>);
  }

  public static explicit operator GS1<T> (GenericClass<T> G)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_expl",typeof(T));
    return default(GS1<T>);
  }

  protected class NestedClass { }
  protected struct NestedStruct { }
  protected interface NestedInterface { }
  protected delegate void NestedDelegate();
  protected enum NestedEnum { }
  
}

actual output:
(798,24): error CS2681: 'GC1<T>.Equals(object)' is not pure enough. It either overrides or implements 'object.Equals(object)' which is marked as '[Pure][Reads(ReadsAttribute.Reads.Nothing)]'
(802,23): error CS2681: 'GC1<T>.GetHashCode()' is not pure enough. It either overrides or implements 'object.GetHashCode()' which is marked as '[Pure]'
expected output:

source(28090):
using System.Collections.Generic;

public class Outer<T> : IEnumerable<Outer<T>.Inner>
{
  public class Inner : List<T> { }

  private IEnumerable<Inner> x = new List<Inner>();

  IEnumerator<Inner> IEnumerable<Inner>.GetEnumerator() { return x.GetEnumerator(); }

  System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return x.GetEnumerator(); }
}

public class Test
{
  public void Method()
  {
    Outer<int> o = new Outer<int>();
    int sum = 0;
    foreach (Outer<int>.Inner i in o)
    {
      sum += i.Count; 
    }
  }
  public static void Main(){}
}

actual output:
(3,14): error CS0536: 'Outer<T>' does not implement interface member 'System.Collections.Generic.IEnumerable<Outer<T>.Inner>.GetEnumerator()'. 'Outer<T>.System.Collections.Generic.IEnumerable<Outer<T>.Inner>.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(9,41): (Location of symbol related to previous error)
(3,14): error CS0536: 'Outer<T>' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'Outer<T>.System.Collections.IEnumerable.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(11,65): (Location of symbol related to previous error)
(9,41): error CS0539: 'Outer<T>.System.Collections.Generic.IEnumerable<Outer<T>.Inner>.GetEnumerator()' in explicit interface declaration does not match a member of interface 'System.Collections.Generic.IEnumerable<Outer<T>.Inner>'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(11,65): error CS0539: 'Outer<T>.System.Collections.IEnumerable.GetEnumerator()' in explicit interface declaration does not match a member of interface 'System.Collections.IEnumerable'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
expected output:

source(28261):
using System;

public class Gen<T>  
{
  public int val = 0;
  public Gen(int val) { this.val = val; }

  public static Gen<T> operator ++ (Gen<T> g)
  {
    return new Gen<T>(g.val+1);
  }

  public override string ToString() { return val.ToString();}
    
}
  
public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {     
    Gen<string> g = new Gen<string>(0);
    Test.Eval(g++.val==0);
    Test.Eval(++g.val==2);
    
    if (result)
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
}

actual output:
(13,26): error CS0508: 'Gen<T>.ToString()': cannot change return type when overriding inherited member 'object.ToString()'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(13,26): error CS2681: 'Gen<T>.ToString()' is not pure enough. It either overrides or implements 'object.ToString()' which is marked as '[Pure]'
expected output:

source(28395):
using System;
using System.Collections;
// foreach with null enumerator should fail
class MyEnumerable : IEnumerable
{
    public IEnumerator GetEnumerator() { return null; }
}
static class Test
{
   static void Main()
   {
      try
      {
         foreach (object o in new MyEnumerable())
         {
            Console.WriteLine(o);
         }
         Console.WriteLine("FAIL");
      } catch (NullReferenceException) {
         Console.WriteLine("PASS");
      }
   }
}

actual output:
(4,7): error CS0536: 'MyEnumerable' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'MyEnumerable.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(6,24): (Location of symbol related to previous error)
expected output:
PASS
source(29652):
using System;
using System.Collections;

class C:IEnumerable{
  int[] xs;
  public IEnumerator GetEnumerator(){ 
    foreach (int x in xs)
      yield return x; 
  }
  public static void Main(){}
}

actual output:
(4,7): error CS0536: 'C' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'C.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(6,22): (Location of symbol related to previous error)
expected output:

source(30867):
// Test code gen bug having to do with a change in explicit coercions
//
// The ? expression failed to generate a box and castclass in the
// second branch
using System;
using System.Collections.Generic;

struct Seq<Node> : IEnumerable<Node> {

    public IEnumerable<Node>! OldTopologicalSort()
    {
        Pair<bool,Seq<Node>> result = this.TopSort();
        return  result.First ? result.Second : (IEnumerable<Node>)new Seq<Node>();
    }

    Pair<bool, Seq<Node>> TopSort() {
        return new Pair<bool, Seq<Node>>();
    }

    public IEnumerator<Node> GetEnumerator() {
        yield return default(Node);
    }

    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
        yield return null;
    }

}
    public struct Pair<T1,T2>
    {
        private T1 first;
        private T2 second;

        public T1 First { get { return first; } }
        public T2 Second { get { return second; } }

        public Pair(T1 first, T2 second)
        {
            this.first = first;
            this.second = second;
        }
    }

class C {
    public static void Main() {
        IEnumerable<string> ie = new Seq<string>().OldTopologicalSort();

        foreach (string s in ie) {
            Console.WriteLine(s);
        }
    }
}

actual output:
(8,8): error CS0536: 'Seq<Node>' does not implement interface member 'System.Collections.Generic.IEnumerable<Node>.GetEnumerator()'. 'Seq<Node>.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(20,30): (Location of symbol related to previous error)
(8,8): error CS0536: 'Seq<Node>' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'Seq<Node>.System.Collections.IEnumerable.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(24,67): (Location of symbol related to previous error)
(24,67): error CS0539: 'Seq<Node>.System.Collections.IEnumerable.GetEnumerator()' in explicit interface declaration does not match a member of interface 'System.Collections.IEnumerable'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
expected output:

source(30892):
// Test indirection when ref UIntPtr* is used.
using System;

unsafe class Test {

    public static void Main() {
        UIntPtr*[] ptrarr = new UIntPtr*[2];

        ptrarr[0] = (UIntPtr*)0xfc;
        ptrarr[1] = (UIntPtr*)0xff00ff00ff00;

        UIntPtr* ptr = Simple(ref ptrarr[0]);

        Console.WriteLine("ptr = {0:X}", (ulong)ptr);
    }


    static UIntPtr* Simple(ref UIntPtr *framePointer)
    {
        return framePointer + 1;
    }
}

actual output:
ptr = 104
expected output:
ptr = 100
source(30948):
using System;

unsafe class Test {

    public static void Main() {
        int[] arr = new int[2];
        arr[0] = 55;
        arr[1] = 77;

        fixed (int* ptr = &arr[0]) {
            TestIncPtr(ptr);
        }

        fixed (int* ptr = &arr[1]) {
            TestDecPtr(ptr);
        }

    }

    public static void TestIncPtr(int* ptr) {
        int* tmp1 = ptr;
        PrePtrInc(ref tmp1);
        Console.WriteLine("{0}", *tmp1);

        int* tmp2 = ptr;
        PostPtrInc(ref tmp2);
        Console.WriteLine("{0}", *tmp2);
    }

    public static void TestDecPtr(int* ptr) {
        int* tmp1 = ptr;
        PrePtrDec(ref tmp1);
        Console.WriteLine("{0}", *tmp1);

        int* tmp2 = ptr;
        PostPtrDec(ref tmp2);
        Console.WriteLine("{0}", *tmp2);
    }

    public static void PostPtrDec(ref int* ptr) {
        ptr--;
    }
    public static void PrePtrDec(ref int* ptr) {
        --ptr;
    }
    public static void PostPtrInc(ref int* ptr) {
        ptr++;
    }
    public static void PrePtrInc(ref int* ptr) {
        ++ptr;
    }
}

actual output:
Common Language Runtime detected an invalid program.
expected output:
77
77
55
55
.\CSharpConformance.suite had 13 failures
.\SpecSharpConformance.suite failed
source(2206):
using System;
using System.Collections;
namespace N{
  struct Pair{
    int Fst, Snd;
    public Pair(int fst, int snd) {
        Fst = fst; Snd = snd;
    }
    public override string ToString() {
        return "("+Fst+","+Snd+")";
    }
    public override int GetHashCode() {
      return Fst*1000 ^ Snd;
    }
    
//    public override bool Equals(object value) {
//      if (!value is //) return false;
//      // p = (//) value;
//      return this.Fst == p.Fst && this.Snd == p.Snd;
//    }
  }
  
  struct Map:IEnumerable {
    Hashtable h;
    public void Add(object key, object value){
      if (h==null) h = new Hashtable();
      h.Add(key,value);
    }
    public IEnumerator GetEnumerator() {
      if (h==null) h = new Hashtable();
      return h.GetEnumerator();
    }
  }   
  
  class M { 
    static void Print(string s, IEnumerable! xs) {
        Console.Write(s+": ");
            foreach(DictionaryEntry d in xs){ Console.Write(d.Key); Console.Write("~>"); Console.Write(d.Value); Console.Write(" "); } 
        Console.WriteLine();
    }
    public static int Main(){
        int[] int0_2 = new int[]{0,1,2};

        Print("MapDisplay", new Map{});
        Print("MapDisplay", new Map{1~>'a',2~>'b',3~>'c'});
        Print("MapDisplay", new Map{int i in int0_2;  i ~> i*i });
        Print("MapComprehension", new Map{int i in new int[0]; i ~> i*i });
        Print("MapComprehension", new Map{int i in int0_2; i ~> i*i });
        Print("MapComprehension", new Map{int i in int0_2, i%2==0; i ~> i*i });
        //Print("MapComprehension", new Map{int i in int0_2, j in int0_2; new Pair(i,j)~>i*j });
        //Print("MapComprehension", new Map{int i in int0_2, i%2 == 0, j in int0_2, j %2 == 1; new Pair(i,j)~>i*j });
        Print("MapComprehension", new Map{int i in new int[0]; i~>i; default 99~>99 });
        return 0;
    }
  }
}

actual output:
(23,10): error CS0536: 'N.Map' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'N.Map.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(29,24): (Location of symbol related to previous error)
expected output:
MapDisplay: 
MapDisplay: 3~>c 2~>b 1~>a 
MapDisplay: 2~>4 1~>1 0~>0 
MapComprehension: 
MapComprehension: 2~>4 1~>1 0~>0 
MapComprehension: 2~>4 0~>0 
MapComprehension: 99~>99 
source(2270):
// BUGBUG!! Should be able to do non-null checking on this one. For some reason, it doesn't work
using System;
using System.Collections;
namespace N{
  struct Pair{
    int Fst, Snd;
    public Pair(int fst, int snd) {
        Fst = fst; Snd = snd;
    }
    public override string ToString() {
        return "("+Fst+","+Snd+")";
    }
//    public override bool Equals(object value) {
//      if (!value is Pair) return false;
//      Pair p = (Pair) value;
//      return this.Fst == p.Fst && this.Snd == p.Snd;
//    }
  }
  
  struct List:IEnumerable {
    ArrayList h;
    public int Add(object key){
      if (h==null) h = new ArrayList();
      h.Add(key);
      return h.Count;
    }
    public IEnumerator GetEnumerator() {
      if (h==null) h = new ArrayList();
      return h.GetEnumerator();
    }
  }   
  
  class M { 
    static void Print(string s, IEnumerable xs) {
        Console.Write(s+" ");
            foreach(DictionaryEntry d in xs){ Console.Write(d.Key); Console.Write("~>"); Console.Write(d.Value); Console.Write(" "); } 
        Console.WriteLine();
    }
    public static int Main(){
        int[] int0_2 = new int[]{0,1,2};

        Print("ListDisplay", new List{});
        Print("ListDisplay", new List{1~>'a',2~>'b',3~>'c'});
        Print("ListDisplay", new List{int i in int0_2;  i ~> i*i });
        Print("ListComprehension", new List{int i in new int[0]; i ~> i*i });
        Print("ListComprehension", new List{int i in int0_2; i ~> i*i });
        Print("ListComprehension", new List{int i in int0_2, i%2==0; i ~> i*i });
        Print("ListComprehension", new List{int i in int0_2, j in int0_2; new Pair(i,j)~>i*j });
        Print("ListComprehension", new List{int i in int0_2, i%2 == 0, j in int0_2, j %2 == 1; new Pair(i,j)~>i*j });
        Print("ListComprehension", new List{int i in new int[0]; i~>i; default 99~>99 });
        return 0;
    }
  }
}

actual output:
(20,10): error CS0536: 'N.List' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'N.List.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(27,24): (Location of symbol related to previous error)
expected output:
ListDisplay 
ListDisplay 1~>a 2~>b 3~>c 
ListDisplay 0~>0 1~>1 2~>4 
ListComprehension 
ListComprehension 0~>0 1~>1 2~>4 
ListComprehension 0~>0 2~>4 
ListComprehension (0,0)~>0 (0,1)~>0 (0,2)~>0 (1,0)~>0 (1,1)~>1 (1,2)~>2 (2,0)~>0 (2,1)~>2 (2,2)~>4 
ListComprehension (0,1)~>0 (2,1)~>2 
ListComprehension 99~>99 
source(2440):
// BUGBUG!! Should be able to do non-null checking on this one. For some reason, it doesn't work
using System;
using C=System.Collections;
using System.Collections.Generic;

namespace N{
  
  class Pair{
    public object Fst, Snd;
    public Pair(object fst, object snd) {
        Fst = fst; Snd = snd;
    }
    public override string ToString() {
      return "("+Fst+","+Snd+")";
    }
  }
  
   class M { 
   
    static int Maximum(IEnumerable<int>  xs) {
          int max = 0; bool has = false;
          foreach (int x in xs){
            has = true;
            if (x > max) max = x;
          }
          if (has)
            return max;
          else
            return int.MinValue;
    }

//    static Pair Maximum(IEnumerable<Pair>  xs) {
//          Pair max = new Pair(int.MinValue, int.MinValue);
//          foreach (Pair x in xs)
//            if ((int)x.Fst > (int)max.Fst) max = x;
//            else if ((int)x.Fst == (int)max.Fst && (int)x.Snd > (int)max.Snd) max = x;
//          return max;
//    }
//    
    
    public static int Main(){
        int[] int0_2 = new int[]{0,1,2};

        //Console.WriteLine("Display " + (int)Maximum{}); //int.MinValue
        Console.WriteLine("Display " + Maximum{1,2,3}); //3
        Console.WriteLine("Display " + Maximum{int i in int0_2;  i}); //2
        Console.WriteLine("Comprehension " + Maximum{int i in new int[0]; i }); //int.MinValue
        Console.WriteLine("Comprehension " + Maximum{int i in int0_2; -i}); //0
        Console.WriteLine("Comprehension " + Maximum{int i in int0_2, i%2 == 1; i  }); //1
        //Console.WriteLine("Comprehension " + Maximum{int i in int0_2, j in int0_2; new Pair(i,j) }); // 2,2
        //Console.WriteLine("Comprehension " + Maximum{int i in int0_2, i%2 == 0, j in int0_2, j %2 == 1; new Pair(i,j)}); // 1,1
        Console.WriteLine("Comprehension" + Maximum {int i in new int[0]; i; default 99 }); //99
        return 0;
    }
  }
}

actual output:
(13,28): error CS0508: 'N.Pair.ToString()': cannot change return type when overriding inherited member 'object.ToString()'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(13,28): error CS2681: 'N.Pair.ToString()' is not pure enough. It either overrides or implements 'object.ToString()' which is marked as '[Pure]'
expected output:
Display 3
Display 2
Comprehension -2147483648
Comprehension 0
Comprehension 1
Comprehension99
source(3133):
// If the body of an expose block terminates with a checked exception, then an attempt is made to pack the object; if successful, the checked exception propagates unchanged
using System;
using Microsoft.Contracts;
class TooBigException : CheckedException{}
class FooBar{
  int x;
  int y;
  invariant 2 * x == y;
  public FooBar(int x)
    requires int.MinValue / 2 <= x && x <= int.MaxValue / 2;
  {
    this.x = x;
    this.y = 2 * x;
  }
  public void IncrementX() throws TooBigException; {
    additive expose (this){
      x++;
      if (int.MaxValue - 2 < y){
        x--;
        throw new TooBigException();
      }
      y += 2;
    }
  }
  static void Main(){
	FooBar fb = new FooBar(int.MaxValue / 2);
    try{
      fb.IncrementX();
	}catch(TooBigException){
      if (!((!)Guard.GetFrameGuard(fb, typeof(FooBar))).CanStartWriting)
         Console.WriteLine("FAIL");
      Console.WriteLine("PASS");
      return;
	}
    Console.WriteLine("FAIL");
  }
}

actual output:
Common Language Runtime detected an invalid program.
expected output:
PASS
source(3171):
// If the body of an expose block terminates with a checked exception, then an attempt is made to pack the object; if unsuccessful, the checked exception is dropped and a GuardException is thrown
using System;
using Microsoft.Contracts;
class TooBigException : CheckedException{}
class FooBar{
  int x;
  int y;
  invariant 2 * x == y;
  public FooBar(int x)
    requires int.MinValue / 2 <= x && x <= int.MaxValue / 2;
  {
    this.x = x;
    this.y = 2 * x;
  }
  public void IncrementX() throws TooBigException; {
    additive expose (this){
      x++;
      if (int.MaxValue - 2 < y){
        throw new TooBigException();
      }
      y += 2;
    }
  }
  static void Main() throws TooBigException; {
	FooBar fb = new FooBar(int.MaxValue / 2);
    try{
      fb.IncrementX();
	}catch(GuardException){
      Console.WriteLine("PASS");
      return;
	}
    Console.WriteLine("FAIL");
  }
}

actual output:
Common Language Runtime detected an invalid program.
expected output:
PASS
source(3209):
// If the body of an expose block terminates with an unchecked exception, then no attempt is made to pack the object; the unchecked exception is always propagated unchanged
using System;
using Microsoft.Contracts;
class TooBigException : Exception {}
class FooBar{
  int x;
  int y;
  invariant 2 * x == y;
  public FooBar(int x)
    requires int.MinValue / 2 <= x && x <= int.MaxValue / 2;
  {
    this.x = x;
    this.y = 2 * x;
  }
  public void IncrementX() {
    additive expose (this){
      x++;
      if (int.MaxValue - 2 < y){
        throw new TooBigException();
      }
      y += 2;
    }
  }
  static void Main(){
	FooBar fb = new FooBar(int.MaxValue / 2);
    try{
      fb.IncrementX();
	}catch(TooBigException){
      Console.WriteLine("PASS");
      return;
	}
    Console.WriteLine("FAIL");
  }
}

actual output:
Common Language Runtime detected an invalid program.
expected output:
PASS
source(5028):
using System;
public class A{ public override string! ToString() { return "a"; } }
public class B:A{ public override string! ToString() { return "b"; } }
public class C:B{ public override string! ToString() { return "c"; } }
public class M{
  public static void f(object! o){
    string s = o.ToString();
    Console.WriteLine(s);
  }
  public static void Main(){
    f(new A());
    f(new B());
    f(new C());
  }
}

actual output:
(2,41): error CS2681: 'A.ToString()' is not pure enough. It either overrides or implements 'object.ToString()' which is marked as '[Pure]'
expected output:
a
b
c
source(5049):
using System;
public class A{ public override string! ToString() { return "a"; } }
public class B:A{ public override string ToString() { return "b"; } }
public class C:B{ public override string! ToString() { return "c"; } }
public class M{
  public static void f(object! o){
    string s = o.ToString();
    Console.WriteLine(s);
  }
  public static void Main(){
    f(new A());
    f(new B());
    f(new C());
  }
}

actual output:
(2,41): error CS2681: 'A.ToString()' is not pure enough. It either overrides or implements 'object.ToString()' which is marked as '[Pure]'
(3,42): error CS0508: 'B.ToString()': cannot change return type when overriding inherited member 'A.ToString()'
(2,41): (Location of symbol related to previous error)
expected output:
(3,42): error CS0508: 'B.ToString()': cannot change return type when overriding inherited member 'A.ToString()'
(2,41): (Location of symbol related to previous error)
source(6127):
using System;
using Microsoft.Contracts;

public interface Interface{}
[Immutable] public interface ImmutableInterface{}
public class C : ImmutableInterface {} // error: Mutable classes cannot implemement immutable interfaces
public class B : Interface {} 
[Immutable] public class ImmutableClass : Interface, ImmutableInterface {} 
[Immutable] public class ImmutableB : B {} // error: immutable classes can not have mutable base classes
public class D : ImmutableClass {} // error: Mutable classes can not have immutable base classes
[Immutable] public class ImmutableOwnerClass  {
  [Rep] ImmutableClass r0; // error: Peer and rep fields cannot be of immutable type
  [Peer] ImmutableClass p0;  // error: Immutable classes cannot have peer fields + error: Peer and rep fields cannot be of immutable type
  [Rep] ImmutableInterface r1; // error: Peer and rep fields cannot be of immutable type
  [Peer] ImmutableInterface p1; // error: Immutable classes cannot have peer fields + error: Peer and rep fields cannot be of immutable type
  [Rep] B r2; 
  [Peer] B p2;  // error: Immutable classes cannot have peer fields
  [Peer] string s;  // should generate an error once System.String has the [Immutable] attribute
  B b;
  Interface i;
  ImmutableInterface imf;
  ImmutableClass imc;
} 
[Immutable] class F {}
[Immutable]
class Initializaion0 {
  private int x;
  private F! f;

  public Initializaion0() {
    f = this.f; // error: Keyword this is not available
    x = this.x + 1; // error: Keyword this is not available
    base();
  }
}
[Immutable]
class Initializaion1 {
  private int x;
  private F! f;

  public Initializaion1() { // error: last statement of an immutable class's constructor must be base call + error: base call "in the middle"
    f = new F();
    this.x = 2;
    base();  
    f = this.f; 
    x = x + 1;
  }
}
[Immutable]
class Initializaion2 {
  private int x;
  private F! f;

  public Initializaion2() { // error: last stmt is not base or this call
    f = this.f; 
    x = this.x + 1; 
  }
}
[Immutable]
class Initialization3 {
  private int x;
  private F! f;

  public Initialization3() { 
    this(new F(),72);
  }

  private Initialization3(F f0, int x0) { // error: last stmt is not base or this call
    f = f0; 
    x = x0; 
  }
}

actual output:
(6,14): error CS2686: Mutable classes cannot implement immutable interfaces.
(9,26): error CS2685: Immutable classes cannot have mutable base classes.
(10,14): error CS2684: Mutable classes cannot have immutable base classes.
(12,24): error CS2688: Peer and rep fields cannot be of immutable type.
(13,25): error CS2689: Immutable classes cannot have peer fields.
(13,25): error CS2688: Peer and rep fields cannot be of immutable type.
(14,28): error CS2688: Peer and rep fields cannot be of immutable type.
(15,29): error CS2689: Immutable classes cannot have peer fields.
(15,29): error CS2688: Peer and rep fields cannot be of immutable type.
(17,12): error CS2689: Immutable classes cannot have peer fields.
(18,17): error CS2689: Immutable classes cannot have peer fields.
(18,17): error CS2688: Peer and rep fields cannot be of immutable type.
(31,9): error CS0027: Keyword this is not available in the current context
(32,9): error CS0027: Keyword this is not available in the current context
expected output:
(6,14): error CS2686: Mutable classes cannot implement immutable interfaces.
(9,26): error CS2685: Immutable classes cannot have mutable base classes.
(10,14): error CS2684: Mutable classes cannot have immutable base classes.
(12,24): error CS2688: Peer and rep fields cannot be of immutable type.
(13,25): error CS2689: Immutable classes cannot have peer fields.
(13,25): error CS2688: Peer and rep fields cannot be of immutable type.
(14,28): error CS2688: Peer and rep fields cannot be of immutable type.
(15,29): error CS2689: Immutable classes cannot have peer fields.
(15,29): error CS2688: Peer and rep fields cannot be of immutable type.
(17,12): error CS2689: Immutable classes cannot have peer fields.
(18,17): error CS2689: Immutable classes cannot have peer fields.
(31,9): error CS0027: Keyword this is not available in the current context
(32,9): error CS0027: Keyword this is not available in the current context
.\SpecSharpConformance.suite had 9 failures
.\SpecSharpConformanceDefiniteAssignment.suite failed
source(581):
// Check that instance calls on structs act as uses of the struct contents.
using System;
using System.Collections;
namespace N{
  struct Map:IEnumerable {
    Hashtable h;
    public void Add(object key, object value){
      if (h==null) h = new Hashtable();
      h.Add(key,value);
    }
    public IEnumerator GetEnumerator() {
      if (h==null) h = new Hashtable();
      return h.GetEnumerator();
    }
  }

  class M {
    public static int Main(){

        Map m = new Map{1~>'a'};
        return 0;
    }
  }
}

actual output:
(5,10): error CS0536: 'N.Map' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'N.Map.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(11,24): (Location of symbol related to previous error)
expected output:
(20,13): warning CS0219: The variable 'm' is assigned but its value is never used
source(1303):
using System;
using Microsoft.Contracts;

class Node {
   public NodePool! graph;
   string! info;
   [Delayed] public Node([Delayed] NodePool! g, string! i){
     this.graph = g;
     if (this.graph == null) // this is not allowed in earlier version but is ok now. 
      	System.Console.WriteLine("this.graph is null");
     else 
      	System.Console.WriteLine("this.graph is not null");
     info = i;
   }
}

class NodePool { 
   // a pool of nodes
   Node! head; 
   public Node! sen;
   
   public NodePool() {
     head = new Node(this, "head");
     sen = new Node(this, "sentinel");
   }   
}

public class Program
{
  static void Main(string[]! args)
    requires forall{string s in args; s != null};
  {
    // how about this version, which should be similar 
    NodePool pool = new NodePool() ; // new Node(pool, "head"), new Node(pool, "sentinel"));
    System.Console.WriteLine("{0}", pool); 
  }
}

actual output:
Common Language Runtime detected an invalid program.
expected output:
this.graph is not null
this.graph is not null
NodePool
.\SpecSharpConformanceDefiniteAssignment.suite had 2 failures
.\SpecSharpConformanceNonNull.suite failed
source(1077):
// check that non null arrays of non null things work

namespace MyNS
{
  class MyClass {

    void TestMeth(object![]! data) {
      object! o = data[0];
      string s = o.ToString();
      
      data[1] = s; // should fail
      
    }    

    public static void Main() {
    }
  }

}

actual output:

expected output:
(11,17): warning CS2613: Conversion to 'string!' fails if the value is null
source(1581):
public class Class1{
  public Class1(bool b, string x, string! y)
  {
			string s = b ? x : y;
			System.Console.WriteLine(s);
  }
  public static void Main(){
    new Class1(true, "foo", "bar");
    new Class1(false, "foo", "bar");
  }
}

actual output:
Common Language Runtime detected an invalid program.
expected output:
foo
bar
source(2478):
public class MyPrinter {
  public static void Main() {
    MyPrinter mp = new MyPrinter();
    System.Console.WriteLine("Main says: {0}", mp);
  }

  public override string! ToString() {
    return "Hello, this is MyPrinter";
  }
}

actual output:
(7,27): error CS2681: 'MyPrinter.ToString()' is not pure enough. It either overrides or implements 'object.ToString()' which is marked as '[Pure]'
expected output:
Main says: Hello, this is MyPrinter
source(2583):
// This demonstrated a bug where the type of the parameter to the closure class's ctor was
// always wrapped with a non-null type even if it was a struct.
using System;
using System.Collections.Generic;
public struct D<T> : IEnumerable<T> {
  T[] xs;
  public IEnumerator<T> GetEnumerator() {
    if (xs == null) yield break;
    for (int i = 0; i < (xs == null ? 0 : xs.Length); i++)
      yield return xs[i];
  }
  System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator(){
    return ((IEnumerable<T>)this).GetEnumerator();
  }
}
class Program { static void Main(string[] args) {} }

actual output:
(5,15): error CS0536: 'D<T>' does not implement interface member 'System.Collections.Generic.IEnumerable<T>.GetEnumerator()'. 'D<T>.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(7,25): (Location of symbol related to previous error)
(5,15): error CS0536: 'D<T>' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'D<T>.System.Collections.IEnumerable.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(12,65): (Location of symbol related to previous error)
(12,65): error CS0539: 'D<T>.System.Collections.IEnumerable.GetEnumerator()' in explicit interface declaration does not match a member of interface 'System.Collections.IEnumerable'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
expected output:
(10,20): warning CS2638: Using possibly null pointer as array
source(2608):
using System;
using System.Collections.Generic;
 
public class Node<T>{
  public T elt;
  public Node<T> next;
}
public struct C<T> : IEnumerable<T> {
  Node<T> head;
  C(Node<T>! y) { this.head = y; }
  public IEnumerator<T> GetEnumerator() {
    for (Node<T> t = this.head; t != null; t = (t == null ? null : t.next))
      yield return t.elt;
  }
  System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator(){
    return ((IEnumerable<T>)this).GetEnumerator();
  }
}
public class Test {
  public static void Main() {}
}

actual output:
(8,15): error CS0536: 'C<T>' does not implement interface member 'System.Collections.Generic.IEnumerable<T>.GetEnumerator()'. 'C<T>.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(11,25): (Location of symbol related to previous error)
(8,15): error CS0536: 'C<T>' does not implement interface member 'System.Collections.IEnumerable.GetEnumerator()'. 'C<T>.System.Collections.IEnumerable.GetEnumerator()' is either static, not public, or has the wrong return type.
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
(15,65): (Location of symbol related to previous error)
(15,65): error CS0539: 'C<T>.System.Collections.IEnumerable.GetEnumerator()' in explicit interface declaration does not match a member of interface 'System.Collections.IEnumerable'
(0,0): C:\Windows\Microsoft.NET\Framework64\v2.0.50727\mscorlib.dll: (Location of symbol related to previous error)
expected output:

source(3043):
//
//  Test that non-null type of this is captured in closure
//
namespace Microsoft.MidoriTest
{
    using System;
    using System.Collections;

    public class Chore
    {
        public delegate void Thunk();
        public Chore(Thunk/*!*/ f) {
        }
    }

    internal class IntMap
    {
        private readonly IntMap/*!*/ _function;
        private readonly Queue/*!*/ /*<Chore>*/ _queue;

        public IntMap() {
           _function = this;
           _queue = new Queue();
        }

        public IntMap(IntMap/*!*/ f) {
            _function = f;
            _queue = new Queue();
        }

        public void Get(int n, int f) {
            _queue.Enqueue(new Chore(delegate() {
                _function.Get(n, f);
            }));
            Console.WriteLine("Get called");
        }

        public static void Main() {

            IntMap m = new IntMap();
            IntMap n = new IntMap(m);
            
            n.Get(1,2);       
        }

    }
}

actual output:
Common Language Runtime detected an invalid program.
expected output:
Get called
source(3134):
using System;
using Microsoft.Contracts;

class Node {
   public NodePool! graph;
   string! info;
   [Delayed] public Node([Delayed] NodePool! g, string! i){
     this.graph = g;
     if (this.graph == null) // this is not allowed in earlier version but is ok now. 
      	System.Console.WriteLine("this.graph is null");
     else 
      	System.Console.WriteLine("this.graph is not null");
     info = i;
   }
}

class NodePool { 
   // a pool of nodes
   Node! head; 
   public Node! sen;
   
   public NodePool() {
     head = new Node(this, "head");
     sen = new Node(this, "sentinel");
   }   
}

public class Program
{
  static void Main(string[]! args)
    requires forall{string s in args; s != null};
  {
    // how about this version, which should be similar 
    NodePool pool = new NodePool() ; // new Node(pool, "head"), new Node(pool, "sentinel"));
    System.Console.WriteLine("{0}", pool); 
  }
}

actual output:
Common Language Runtime detected an invalid program.
expected output:
this.graph is not null
this.graph is not null
NodePool
.\SpecSharpConformanceNonNull.suite had 7 failures
